---
title: "Item Response Warehouse"
subtitle: "The Item Response Warehouse (IRW) is a collection of open, harmonized item response datasets."
description: |  
  * Open: The data are licensed for reformatting and public reuse. Their provenance is documented and code used to transform original data to meet the IRW data standard is available.
  
  * Harmonized: The data are formatted to a common standard. The goal of the IRW is to make large quantities of data available for standardized analysis given the common formatting. 
  
  * Item Response: The IRW is comprised of cross-classified item responses. The key element required of data for inclusion in the IRW is that the data need to report individual responses that are cross-classified by the focus of measurement (typically a person) and the measurement tool (typically an item).
  
  These datasets in IRW span a wide range of measures; examples include measures of ability in education settings, measures of partisanship based on voting records, and personality measures based on survey questions.  Responses can be scored in a variety of ways (dichotomous, polytomous, continuous) and may contain additional data (e.g., response time).

title-block-banner: "#2780e3"
title-block-banner-color: white
callout-icon: false
---

{{< include _load-data-explore.qmd >}}

{{< include components/_interval.qmd >}}
{{< include components/_hist.qmd >}}
{{< include components/_tol.qmd >}}

```{ojs prelims}
// import newer version of observable plot than the one embedded in quarto 
Plot = import("https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm")
import {yamultiselect} from '@saneef/yet-another-multi-select'

md = transpose(datasets)
```

{{< include components/_style.qmd >}}

```{ojs info}
// info for numeric variables
_vi = ({
  "n_responses":               { label: "Number responses (n_responses)",                        base: 10 },
  "n_categories":              { label: "Number categories (n_categories)",                      base:  2 },
  "n_participants":            { label: "Number participants (n_participants)",                  base: 10 },
  "n_items":                   { label: "Number items (n_items)",                                base: 10 },
  "responses_per_participant": { label: "Responses per participant (responses_per_participant)", base: 10 },
  "responses_per_item":        { label: "Responses per item (responses_per_item)",               base: 10 },
  "density":                   { label: "Density (n_responses/(n_participants*n_items))",        base: 10 }
})

// compute and add in ranges for numeric variables
vi = Object.fromEntries(Object.entries(_vi).map(([k, v]) => [k, {...v, range: log_range(md.map(d => d[k]), v.base)}]))

// info for tag variables
ti = ({
  "longitudinal":                          { label: "Longitudinal"                          } ,
  "age_range":                             { label: "Age range"                             } ,
  "child_age__for_child_focused_studies_": { label: "Child age (for child-focused studies)" } ,
  "construct_type":                        { label: "Construct type"                        } ,
  "sample":                                { label: "Sample"                                } ,
  "measurement_tool":                      { label: "Measurement tool"                      } ,
  "item_format":                           { label: "Item format"                           } ,
  "primary_language_s_":                   { label: "Primary language(s)"                   } ,
  "license":                               { label: "License"                               } ,
})
```

```{ojs filter-funs}
// formatting function for how two ended slider displays selected range
// (use SI prefix if base 10 otherwise  default format)
pow_format = (v, b) => b === 10 ? d3.format("~s")(Math.pow(b, v)) : Plot.formatNumber("en-US")(Math.pow(b, v))
interval_format = (b) => ([start, end]) => `[${pow_format(start, b)}; ${pow_format(end, b)}]`

// any base log
log = (x, b) => Math.log(x) / Math.log(b)
// log-transformed extent of array of values
log_range = (x, b) => [Math.floor(log(d3.min(x), b)), Math.ceil(log(d3.max(x), b))]

// interval input for a given numeric variable
var_interval = (v) => {
  //return interval(log_range(md.map(d => d[v]), vi[v].base), {
  return interval(vi[v].range, {
    step: 1, label: vi[v].label, format: interval_format(vi[v].base), width: "95%"
  })
}

// checkbox input for a given tag variable
tag_checkbox = (t) => Inputs.checkbox(tags[t], {value: tags[t]})
```

:::::: {.column-screen-inset}
::::: {layout="[ [19,55,26] ]"}

:::: {.panel-input}

{{< bi filter >}} _Filter by quantitative properties._

::: {.side-inputs}

::: {.filters-container}

```{ojs filter-responses}
viewof n_responses_range = var_interval("n_responses")
```

```{ojs filter-categories}
viewof n_categories_range = var_interval("n_categories")
```

```{ojs filter-participants}
viewof n_participants_range = var_interval("n_participants")
```

```{ojs filter-items}
viewof n_items_range = var_interval("n_items")
```

```{ojs filter-responses-per-participant}
viewof responses_per_participant_range = var_interval("responses_per_participant")
```

```{ojs filter-responses-per-item}
viewof responses_per_item_range = var_interval("responses_per_item")
```

```{ojs filter-density}
viewof density_range = var_interval("density")
```


:::
:::

-----

{{< bi filter >}} _Filter by variables._

::: {.side-inputs}

::: {.filters-container}

```{ojs filter-variable}
viewof variable = yamultiselect(vars.variable, { label: "Variable" })
```

```{ojs filter-prefix}
viewof prefix = yamultiselect(vars.prefix, { label: "Variable prefix" })
```

:::
:::

::::

:::: {.panel-fill}

```{ojs data-filtered}
// generate range filter function for a given numeric variable and input range
range_filter = (v, v_range) => {
  return (d) => d[v] >= Math.pow(vi[v].base, v_range[0]) &
                d[v] <= Math.pow(vi[v].base, v_range[1])
}

// generate overlap filter function for a given categorical variable and input values
overlap_filter = (t, t_vals) => {
  return (d) => t_vals.some(v => d[t].includes(v))
}

// generate overlap filter function as above but that defaults to including everything if input values empty
overlap_null_filter = (t, t_vals) => {
  return (d) => t_vals.length ? t_vals.some(v => d[t].includes(v)) : true
}

// specify range-based inputs (as variable, values)
range_inputs = ([
  { v: "n_responses",               vals: n_responses_range               },
  { v: "n_categories",              vals: n_categories_range              },
  { v: "n_participants",            vals: n_participants_range            },
  { v: "n_items",                   vals: n_items_range                   },
  { v: "responses_per_participant", vals: responses_per_participant_range },
  { v: "responses_per_item",        vals: responses_per_item_range        },
  { v: "density",                   vals: density_range                   },
])

// specify overlap-based inputs (as variable, values)
overlap_inputs = ([
  { v: "longitudinal",                          vals: longitudinal_vals     },
  { v: "age_range",                             vals: age_range_vals        },
  { v: "child_age__for_child_focused_studies_", vals: child_age_vals        },
  { v: "construct_type",                        vals: construct_type_vals   },
  { v: "sample",                                vals: sample_vals           },
  { v: "measurement_tool",                      vals: measurement_tool_vals },
  { v: "item_format",                           vals: item_format_vals      },
  { v: "primary_language_s_",                   vals: primary_language_vals },
  { v: "license",                               vals: license_vals          },
])

// specify variable and prefix filters
var_inputs = ([
  { v: "variable", vals: variable },
  { v: "prefix",   vals: prefix   },
])

// generate filter function for each input and combine them
range_filters = range_inputs.map(({ v, vals }) => range_filter(v, vals))
overlap_filters = overlap_inputs.map(({ v, vals }) => overlap_filter(v, vals))
overlap_null_filters = var_inputs.map(({ v, vals }) => overlap_null_filter(v, vals))
all_filters = [...range_filters, ...overlap_filters, ...overlap_null_filters]

// apply filters to metadata
ds = all_filters.reduce((mdf, fun) => mdf.filter(fun), md)
// replace "NA" with null in filtered data
dsf = ds.map(d => Object.fromEntries(Object.entries(d).map(([key, value]) => [key, value === "NA" ? null : value])))
```

:::: {.output-container}

::: {.plot-container}
::: {.plot-inputs}

```{ojs x-var}
num_vars = new Map(Object.entries(vi).map(([key, value]) => [value.label, key]))
viewof x_var = Inputs.select(num_vars, {value: "n_items", label: "X axis"})
```

```{ojs y-var}
viewof y_var = Inputs.select(num_vars, {value: "n_participants", label: "Y axis"})
```

```{ojs color-var}
cat_array = color_vars.map((t) => [ti[t].label, t])
cat_vars = new Map([["None", null], ...cat_array])
viewof color_var = Inputs.select(cat_vars, {label: "Color"})
```

:::


```{ojs scatter}
// color scheme
scheme = tol.QualMuted

// default color when there's no color variable
default_color = "darkgrey"

// color for missing values
unk_color = "lightgrey"

// indicator whether to use color
use_color = color_var !== null

// turn value into array if it isn't one
arrayify = (x) => Array.isArray(x) ? x : [x]

// given array of strings or single string, collapses to one comma separated string
stringify = (x) => x === null ? null : arrayify(x).join(", ")

// domain of values to use for color
color_vals = color_var === null ? default_color : tags[color_var].filter((v) => v !== "NA")

default_symbol = "circle"
select_symbol = "times"

default_size = 1
select_size = 4

// scatter plot
Plot.plot({
  x: {type: "log", base: vi[x_var].base},
  y: {type: "log", base: vi[y_var].base},
  width: 700,
  grid: true,
  color: {
    domain: color_vals,
    range: scheme,
    unknown: unk_color,
    legend: use_color
  },
  marks: [
    // points
    Plot.dot(dsf, {
      x: x_var,
      y: y_var,
      stroke: use_color ? (d) => stringify(d[color_var]) : default_color,
      symbol: (d) => row === null ? default_symbol : d.table !== row.table ? default_symbol : select_symbol,
      r: (d) => row === null ? default_size : d.table !== row.table ? default_size : select_size
    }),
    // regression line
    Plot.linearRegressionY(dsf, {
      x: x_var,
      y: y_var,
      stroke: use_color ? (d) => stringify(d[color_var]) : default_color
    }),
    // tooltips
    Plot.tip(dsf, Plot.pointer({
      x: x_var,
      y: y_var,
      stroke: use_color ? (d) => stringify(d[color_var]) : default_color,
      title: "table",
    }))
  ]
})
```
:::


::: {.table-container}
```{ojs result-message}
html`<i>Filtered to ${ds.length} datasets out of ${md.length} total.</i>`
```

```{ojs table-funs}
// sparkbar element generator given max value and log base
sparkbar = (max, b) => {
  return x => htl.html`<div class="sparkbar" style="width: ${100 * log(x, b) / log(max, b)}%;">${x.toLocaleString("en")}`
}

// sparkbar element generator for a given numeric variable
var_sparkbar = (v) => sparkbar(d3.max(ds, d => d[v]), vi[v].base)

// sparkbars for each numeric variable
sparks = Object.fromEntries(Object.entries(vi).map(([key, value]) => [key, var_sparkbar(key)]))

// inline histogram element given array of values and header string
inlinehist = (vals, head) => {
  return htl.html`<span class="hist">${hist(vals)}${head}</span>`
}

// inline histogram for a given numeric variable
var_hist = (v) => inlinehist(ds.map(d => log(d[v], vi[v].base)), v)

// histograms for each numeric variable
hists = Object.fromEntries(Object.entries(vi).map(([key, value]) => [key, var_hist(key)]))

// combine two arrays into pairs in one array
zip = (a, b) => a.map((k, i) => [k, b[i]])

// set colors for array of values, using default if there are too values
pal = (v, colors, default_color) => v.length <= colors.length ? colors.slice(0, v.length) : Array(v.length).fill(default_color)

// create object with colors for each tag value
tag_colors = Object.fromEntries(Object.entries(tags).map(([tag, tag_values]) => {
  //const vals = tag_values.sort().filter((v) => v !== "NA");
  const vals = tag_values.filter((v) => v !== "NA");
  return [tag, Object.fromEntries(zip(vals, pal(vals, scheme, default_color)))]
}))

// badge element for a given tag and values
badgify = (vals, tag) => htl.html`<div>
  ${arrayify(vals).map(val => htl.html.fragment`
    <span class="badge" style="background-color: ${tag_colors[tag][val]};">${val}</span>`)}
</div>`

// badge elements for each tag
badges = Object.fromEntries(Object.keys(ti).map(tag => [tag, d => badgify(d, tag)]))
```


```{ojs table}
// data table for selected tables
viewof row = Inputs.table(dsf, {
  rows: 20,
  sort: "n_responses", reverse: true,
  required: false, multiple: false,
  //value: dsf[1],
  // show columns "table", all numeric variables, and all tag variables
  columns: ["table", ...Array.from(Object.keys(vi)), ...Array.from(Object.keys(ti))],
  // use inline histograms in header
  header: hists,
  // use sparkbars and badges in cells
  format: {...sparks, ...badges}
})
```
:::

::: {.callout-note collapse=true}

## {{< bi info-circle class=header-icon >}}Information on selected dataset

```{ojs}
// specify which variables to show in info box
info = ({
  "table":       { label: "Dataset"        },
  "description": { label: "Description"    },
  "variables":   { label: "Variables"      },
  "url":         { label: "Link to table"  },
  "reference":   { label: "Reference"      },
  "data_url":    { label: "Link to source" },
  "license":     { label: "License"        },
})

// element for each info entry ($head: $text) with $text wrapped in <a> if head matches "Link"
pullout = (head, text) => html.fragment`<p><b>${head}</b>: ${/Link/.test(head) ? html.fragment`<a href="${text}" target="_blank">${text}</a>` : text}</p>`

// elements for all info entries, placeholder if no table selected
placeholder = "No table selected"
row ? html`<div class="pullout">
  ${Object.entries(info).map(([field, properties]) => pullout(properties.label, row[field]))}
</div>` : html`<div class="pullout"><em>${placeholder}</em></div>`
```
:::

::: {.callout-note collapse=true}

## {{< bi code class=header-icon >}}Code snippet

The R code snippet below uses the <a href="https://itemresponsewarehouse.github.io/Rpkg" target="_blank">irw package</a> to fetch all of the tables that match the filters specified here. _Note: a difference between the functionality of the filters here and the behavior of_ `irw_filter()` _is that specifying values for a given argument of_ `irw_filter()` _will result in_ `NA` _values being dropped, while they can be included here._

```{ojs}
// simple templating function: replace strings of the form "{{variable}}" in the
// template with the corresponding value from values
fillTemplate = (template, values) => {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    return values[key] !== undefined ? values[key] : match;
  });
};

// given array, create string representation R character vector of values
c = (vals) => `c(${vals.map(s => `"${s}"`).join(", ")})`

// construct arguments for range inputs if they're not their default values
is_default_range = (v, vals) => vals[0] === vi[v].range[0] && vals[1] === vi[v].range[1]
range_arg = (v, vals) => is_default_range(v, vals) ? null : `${v} = c(${Math.pow(vi[v].base, vals[0])}, ${Math.pow(vi[v].base, vals[1])})`
range_args = range_inputs.map(({ v, vals }) => range_arg(v, vals))

// construct arguments for overlap inputs if they're not their default values
is_default_overlap = (v, vals) => tags[v].every(t => vals.includes(t))
overlap_arg = (v, vals) => is_default_overlap(v, vals) ? null : `${v} = ${c(vals.filter(e => e !== "NA"))}`
overlap_args = overlap_inputs.filter(d => d.v !== l).map(({ v, vals }) => overlap_arg(v, vals))

// special handling to construct var argument by combining variables and prefixes
var_arg_vals = var_inputs.map(({v, vals}) => v === "prefix" ? vals.map(s => `${s}_`) : vals).flat()
var_arg = var_arg_vals.length ? `var = ${c(var_arg_vals)}` : null

// special handling to construct longitudinal argument as boolean
l = "longitudinal"
long_vals = overlap_inputs.filter(d => d.v === l)[0].vals
long_arg = is_default_overlap(l, long_vals) ? null : `${l} = ${long_vals[0] === "longitudinal" ? "TRUE" : "FALSE"}`

// combine all arguments
filter_args = [...range_args, var_arg, ...overlap_args, long_arg].filter(e => e !== null)
filter_str = filter_args.length ? `\n  ${filter_args.join(",\n  ")}  \n` : ""

// load template and fill arguments into it
r_filter_template = FileAttachment("resources/templates/query_filter_snippet.R").text();
r_filter_snippet = () => fillTemplate(r_filter_template, { filter_str: filter_str })
```

```{ojs}
// code snippet box with copy button
ds.length === 0 ? html`<em>No datasets match filters.</em>` : html`
<div class="pullout">
<div class="code-copy-outer-scaffold">
<div class="sourceCode">
<pre class="sourceCode r code-with-copy">
<code class="sourceCode r">
<span>${r_filter_snippet()}</span></code></pre>
</div>
<button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button>
</div>
</div>
`
```

:::

::::
::::


:::: {.panel-input}

{{< bi filter >}} _Filter by qualitative features._

::: {.side-inputs}

::: {.filters-container}

::: {.callout-note collapse="true"}
## {{< bi graph-up class=header-icon >}}Longitudinality

```{ojs filter-longitudinal}
viewof longitudinal_vals = tag_checkbox("longitudinal")
```
:::

::: {.callout-note collapse="true"}
## {{< bi person-lines-fill class=header-icon >}}Age range

```{ojs filter-age-range}
viewof age_range_vals = tag_checkbox("age_range")
```
:::

::: {.callout-note collapse="true"}
## {{< bi person-arms-up class=header-icon >}}Child age (for child-focused studies)

```{ojs filter-child-age}
viewof child_age_vals = tag_checkbox("child_age__for_child_focused_studies_")
```
:::

::: {.callout-note collapse="true"}
## {{< bi grid class=header-icon >}}Construct type

```{ojs filter-construct-type}
viewof construct_type_vals = tag_checkbox("construct_type")
```
:::

::: {.callout-note collapse="true"}
## {{< bi people class=header-icon >}}Sample

```{ojs filter-sample}
viewof sample_vals = tag_checkbox("sample")
```
:::

::: {.callout-note collapse="true"}
## {{< bi clipboard-data class=header-icon >}}Measurement tool

```{ojs filter-measurement-tool}
viewof measurement_tool_vals = tag_checkbox("measurement_tool")
```
:::

::: {.callout-note collapse="true"}
## {{< bi sliders class=header-icon >}}Item format

```{ojs filter-item-format}
viewof item_format_vals = tag_checkbox("item_format")
```
:::

::: {.callout-note collapse="true"}
## {{< bi translate class=header-icon >}}Primary language(s)

```{ojs filter-primary-language}
viewof primary_language_vals = tag_checkbox("primary_language_s_")
```
:::

::: {.callout-note collapse="true"}
## {{< bi cc-circle class=header-icon >}}License

```{ojs filter-license}
viewof license_vals = tag_checkbox("license")
```
:::

:::
:::
::::
:::::

_If you have any questions or feedback, please feel free to [contact us](contact.qmd)._

::::::
